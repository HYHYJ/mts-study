# 4. 타입스크립트의 함수

- [4. 타입스크립트의 함수](#4-타입스크립트의-함수)
  - [4.3 함수 타입의 서브타입 관계](#43-함수-타입의-서브타입-관계)
    - [4.3.1 반환값 타입에 따른 서브타입 관계](#431-반환값-타입에-따른-서브타입-관계)
    - [4.3.2 인수 타입에 따른 서브타입 관계](#432-인수-타입에-따른-서브타입-관계)
    - [4.3.3 인수의 수에 따른 서브타입 관계](#433-인수의-수에-따른-서브타입-관계)

## 4.3 함수 타입의 서브타입 관계

타입 학습 시, 그 타입을 둘러싼 서브타입 관계가 어떻게 형성됐는지 이해하는 건 매우 중요.

### 4.3.1 반환값 타입에 따른 서브타입 관계

반환값 타입에 의해 서브타입 관계가 발생하는 경우  
S가 T의 서브타입이라면 `(인수 목록) => S`라는 함수 타입은 `(인수 목록) => T`라는 함수 타입의 서브타입이 됨

함수에서 반환한 S 타입의 값을 T 타입으로 간주함으로써 'S 타입의 값을 반환하는 함수'를 'T 타입의 값을 반환하는 함수' 대신 사용할 수 있는 것

```ts
type HasName = {
  name: string;
};
type HasNameAndAge = {
  name: string;
  age: number;
};

const fromAge = (age: number): HasNameAndAge => ({
  name: 'John Smith',
  age,
});

const f: (age: number) => HasName = fromAge;
const obj: HasName = f(100);
```

HasNameAndAge가 HasName의 서브타입 관계.  
(age: number): HasNameAndAge가 (age: number) => HasName의 서브타입

프로그램 실행 시 최종적으로 obj에 `{name: 'John Smith',age}`가 들어가게 됨.  
=> 서브타입 관계의 영향으로 타입 정보보다 더 많은 정보를 지닌 객체를 얻게 된 것.  
타입 정보에 맞춰 정보가 잘려 나가는 일은 없음 => 런타임 작동에 영향을 주지 않는다는 원칙

서브타입 관계에서 void 타입은 특수 작동.  
그 어떤 타입을 반환하는 함수 타입이더라도 void 타입을 반환하는 함수 타입의 서브타입으로 취급.  
void 타입은 반환값이 없음을 나타내므로, 함수에서 어떤 타입을 바환해도 '아무것도 반환하지 않는 함수' 대신 사용 가능

```ts
const f = (name: string) => ({ name });
const g: (name: string) => void = f;
```

### 4.3.2 인수 타입에 따른 서브타입 관계

### 4.3.3 인수의 수에 따른 서브타입 관계
