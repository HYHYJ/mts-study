# 4. 타입스크립트의 함수

- [4. 타입스크립트의 함수](#4-타입스크립트의-함수)
  - [4.1 함수를 만드는 법](#41-함수를-만드는-법)
    - [4.1.1 함수 선언으로 함수 만들기](#411-함수-선언으로-함수-만들기)
      - [함수 선언](#함수-선언)
        - [**✏️return 문**](#️return-문)
        - [⬆️함수선언 호이스팅](#️함수선언-호이스팅)
    - [4.1.2 반환값이 없는 함수 만들기](#412-반환값이-없는-함수-만들기)
      - [반환값이 void 타입인 함수에도 return문을 사용할 수 있다.](#반환값이-void-타입인-함수에도-return문을-사용할-수-있다)
      - [return 문과 세미콜론 생략의 함정](#return-문과-세미콜론-생략의-함정)
    - [4.1.3 함수 표현식으로 함수 만들기](#413-함수-표현식으로-함수-만들기)
      - [함수 표현식](#함수-표현식)
        - [⚠️함수 표현식의 주의점](#️함수-표현식의-주의점)
    - [4.1.4 화살표 함수 표현식으로 함수 만들기](#414-화살표-함수-표현식으로-함수-만들기)
      - [화살표 함수 표현식](#화살표-함수-표현식)
    - [4.1.5 화살표 함수 표현식의 생략형](#415-화살표-함수-표현식의-생략형)
    - [4.1.6 메서드 기법으로 함수 만들기](#416-메서드-기법으로-함수-만들기)
    - [4.1.7 가변 인수 선언](#417-가변-인수-선언)
    - [4.1.8 함수를 호출할 때의 전개 구문](#418-함수를-호출할-때의-전개-구문)
    - [4.1.9 선택적 인수 선언](#419-선택적-인수-선언)
    - [4.1.10 콜백 함수 사용해 보기](#4110-콜백-함수-사용해-보기)

## 4.1 함수를 만드는 법

### 4.1.1 함수 선언으로 함수 만들기

#### 함수 선언

> function 함수명(인수목록): 반환타입 {본문}

- **반환타입:** 함수에서 반환하는 값의 타입을 선언

- **인수**를 받을 려면 인수 목록에 `변수명: 타입`을 기재하여 인수를 선언해야한다.

```js
//함수 선언 예시
function range(min: number, max: number): number[] {
  const result = [];
  for (let i = min; i <= max; i++) {
    result.push(i);
  }
  return result;
}

console.log(range(5, 10)); // [5, 6, 7, 8, 9, 10]이라고 출력된다
```

- 인수: `min`, `max` 두가지, 모두 `number` 타입
- 반환 타입: `number[ ]` 타입.(number의 배열 타입)

```js
// 에러: Argument of type 'string' is not assignable to parameter of type 'number'.
range("5", "10");
// 에러: Expected 2 arguments, but got 1.
range(5);
```

- 만약 인수에 `range("5","10")`과 값이 다른 타입을 넘기거나 `range(5)`와 같이 인수의 수를 잘못 넘기면 컴파일 에러

##### **✏️return 문**

> return 식;

- return 문이 실행되면 함수의 실행이 종료
- return 문보다 뒤에 있는 문은 실행도지 않음.

**return 문 타입검사: 반환하는 것은 `number[]`타입의 값이어야함.**

- 해당 타입이 아닌 값은 컴파일 에러가 발생

```js
function range(min: number, max: number): number[] {
  const result = [];
  for (let i = min; i <= max; i++) {
    result.push(i);
  }
  // 🚨에러: Type 'number' is not assignable to type 'number[]'.
  return max;
}
```

- return 값에 number 타입을 넣으면 에러

##### ⬆️함수선언 호이스팅

호이스팅: 함수 선언보다 앞에서 해당 함수를 사용할 수 있다.(프로그램의 실행 시작 시점부터 이미 존재하게 됨)

### 4.1.2 반환값이 없는 함수 만들기

함수에는 반환값이 있는 것과 없는 것이 있다.

- 앞에 range는 반환값이 있는 함수
- console.log는 반환값이 없는 함수
  ➡️ 반환값이 없는 함수를 선언할때에는 반환값의 타입으로: **void 타입**

```js
//반환값이 없는 함수
function helloWorldNTimes(n: number): void {
  for (let i = 0; i < n; i++) {
    console.log("Hello, world!");
  }
}

helloWorldNTimes(5);
```

- void 타입을 명시함으로써 반환값이 없다고 선언
- return문을 쓰지 않아도됨.
- 자연스럽게 종료됨.

##### 반환값이 void 타입인 함수에도 return문을 사용할 수 있다.

- 조기반환이라고 불리는 방법을 쓰고 싶을 때 사용.
- 조기반환 : return문을 이용해서 조건분기의 결과에 따라 함수의 실행을 그 자리에서 중단시키는 방법
  - 반환값이 없을 경우 `return;`

```js
function helloWorldNTimes2(n: number): void {
  if (n >= 100) {
    console.log(`${n}번은 무리입니다!!!`);
    return;
  }
  for (let i = 0; i < n; i++) {
    console.log("Hello, world!");
  }
}

helloWorldNTimes2(5);
helloWorldNTimes2(150);
```

만약 n으로 100이상의 값이 전달되면 return문으로 프로그램이 종료된다.

##### return 문과 세미콜론 생략의 함정

- 함수의 반환값을 나타내는 return문도 맨 마지막에 ; 이 있으므로 예외가 아니며, 세미콜론을 생략할 수 있다.
  **⚠️세미콜론 생략과 return을 함께 사용할 때 주의 점**
- 세미콜론의 생략기능에 따라 return문이 끊어질 수도 있다.
  - 반환값이 너무 길어서 읽기 쉽게 바꾼 예시
  ```js
  function toSeconds(hours: number, minutes: number, seconds: number): number {
    return;
    hours * 3600 + minutes * 60 + seconds;
  }
  ```
  🚨컴파일 에러 발생!
  - return뒤에 세미콜론이 생략됐다고 간주해 버린다.
  - 반환값이 없는 함수가 되어 봔환 타입이 number라고 선언된 것과 맞지 않아 컴파일 에러가 발생
  ```js
  function toSeconds(hours: number, minutes: number, seconds: number): number {
    return; // <- 🚨이런식으로 세미콜론이 생략된 것으로 처리
    hours * 3600 + minutes * 60 + seconds;
  }
  ```
  ➡️ return과 반환값 사이에 개행하면 안된다🙅‍♂️

### 4.1.3 함수 표현식으로 함수 만들기

#### 함수 표현식

식을 가지고 함수를 만들 수 있음
`function (인수목록): 반환타입 {본문}`

- function뒤에 함수명이 없다.
- 식의 평가 결과는 함수 표현식에의해 만들어진 함수 그자체
- 만든 함수를 이용하기 위해서는 함수를 변수에 넣어야함.

```js
type Human = {
  height: number,
  weight: number,
};
const calcBMI = function (human: Human): number {
  return human.weight / human.height ** 2;
};
const uhyo: Human = { height: 1.84, weight: 72 };
// 21.266540642722116이라고 출력된다
console.log(calcBMI(uhyo));
```

- 함수의 인수에 분해할당을 할수도 있다.
- 변수명 대신에 패턴을 쓰는 것이지만 함수 인수에서는 인수명 대신에 패턴을 쓸 수 있다.
- 인수로 넘겨진 객체의 내용물을 꺼내서 변수에 담을 수 있습니다.
- 함수의 인수인 human은 다음과 같이 분해 할당으로 바꾸어 쓸 수 있습니다.

```js
type Human = {
  height: number,
  weight: number,
};
const calcBMI = function ({ height, weight }: Human): number {
  return weight / height ** 2;
};
const uhyo: Human = { height: 1.84, weight: 72 };
// 21.266540642722116이라고 출력된다
console.log(calcBMI(uhyo));
```

- 인수목록이 {height, weight}:Human 이 됐는데, human이 었던 부분이 패턴으로 바뀌었습니다.
- calcBMI 로 전달된 uhyo는 height가 1.84이고 weight가 72인 객체이므로 calcBMI에 전달될 때 함수 내부에서 변수 height에 1.84, 변수 weight에 72가 대입된다.
- 변수 선언시의 분해 할당과 같이 human. 을 2번쓰지 않아도 된다는 이점

함수도 값의 일종: 함수 표현식으로 함수를 함들수 있는 것

타입스크립트의 값은 원시 값과 객체로 분류할 수 있다.
함수는 원시값이 아니므로 객체입니다.
함수가 값(함수 객체)이므로 이번 예시처럼 함수를 변수 에 대입 할수 있는 것!

##### ⚠️함수 표현식의 주의점

함수선언과 달리 호이스팅 기능이 없다.
함수 표현식은 단순한 변수 선언과 조합해 사용합니다.
단군한 변수 선언의 경우에는 소스코드가 위에서부터 아래도 실핻되므로 아직 선언도지 안흥ㅇ 변수를 사용할 수 없다.
함수표현식으로 만든 함수가 const 선언에 의해 변수 calcBMI에 대입됩니다.
-> const 선언보다 앞의 calcBMI를 사용할 수 없다는 의미

```js
const uhyo: Human = { height: 1.84, weight: 72 };
// 🚨에러: Block-scoped variable 'calcBMI' used before its declaration.
console.log(calcBMI(uhyo));

type Human = {
  height: number,
  weight: number,
};
const calcBMI = function ({ height, weight }: Human): number {
  return weight / height ** 2;
};
```

함수표현식으로 만든 함수 사이에 성질의 차이는 딱히 없다.
함수선언으로 만들어진 함수도 사실 함수 객체가 변수에 들어간 것 뿐

### 4.1.4 화살표 함수 표현식으로 함수 만들기

#### 화살표 함수 표현식

- 함수를 만드는 식

```js
(인수 목록):반환타입 => {본문}
```

- 함수표현식을 대체할 수 있는 또하나의 함수표현식
- 식의 일종
- 함수표현식 보다 화살표 함수 표현식이 더 선호되곤 함.
- 특히, `function`이라는 긴키워드를 쓰지 않아도 된다.
- this를 다룰 때에도 화살표 함수를 사용하는 것이 더 유리하다.

```js
type Human = {
  height: number,
  weight: number,
};
const calcBMI = ({ height, weight }: Human): number => {
  return weight / height ** 2;
};
const uhyo: Human = { height: 1.84, weight: 72 };
// 21.266540642722116이라고 출력된다
console.log(calcBMI(uhyo));
```

### 4.1.5 화살표 함수 표현식의 생략형

화살표 함수 표현식의 생략형 구문은 간단한 함수를 정의할 때 유용

```js
(인수 목록): 반환 타입 => 식
```

생략형에서 넣을 수 있는 것은 하나의 식뿐이다.
➡️생략형을 통상적인 형태

```js
(인수 목록):반환 타입 => {return 식;}
```

```js
// 통상적인 형태
const calcBMI = ({ height, weight }: Human): number => {
  return weight / height ** 2;
};

// 생략형
const calcBMI = ({ height, weight }: Human): number => weight / height ** 2;
```

- 생략현으로는 바로 반환값을 계산하는 함수밖에 만들 수 없으므로 복잡한 처리에는 적합하지 않다.
- 특히 콜백함수를 만들때 곧잘 쓰이는 경향
- 빠지기 쉬운 함정이 있다.
  - 객체 리터럴을 반환값의 식으로 사용하고자 하는 경우
  - calcBMIObject처럼 객체 리터럴을 ()로 감싸야 한다.
  - 감싸지 않으면 오른쪽의 {}가 객체 리터럴이 아니라 통상적ㅇ니 화살표 함수의 본문을 감싸주는 {}로 간주되어 버린다.

```js
type Human = {
  height: number,
  weight: number,
};
type ReturnObj = {
  bmi: number,
};
// 올바른 사용 방법
const calcBMIObject = ({ height, weight }: Human): ReturnObj => ({
  bmi: weight / height ** 2,
});

// 컴파일 에러 발생
// 에러: A function whose declared type is neither 'void' nor 'any' must return a value.
const calcBMIObject2 = ({ height, weight }: Human): ReturnObj => {
  bmi: weight / height ** 2;
};
```

- 마지막calcBMIObject2은 객체 {}가 아니라 통상적인 화살표 함수의 본문을 감싸는 괄호로 간주
- 그 결과 return 문이 없다고 에러

### 4.1.6 메서드 기법으로 함수 만들기

### 4.1.7 가변 인수 선언

### 4.1.8 함수를 호출할 때의 전개 구문

### 4.1.9 선택적 인수 선언

### 4.1.10 콜백 함수 사용해 보기
