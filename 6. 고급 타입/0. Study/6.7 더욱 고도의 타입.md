# 6.7 더욱 고도의 타입

## 6.7.4 mapped types

타입스크립트에서 까다로운 기능으로 top 2중 하나다.
이 기능은 매우 어려운 기능이므로 간단히 설명하려고 합니다.

mapped types 아래와 같은 구문으로 표현되는 타입

```
{[P in K]: T}
```

- `P`는 이 구문내에서 새로 도입되는 타입변수로, T안에서 사용할 수 있습니다.
- `K`는 프로퍼티명이 될 수 있는 타입(구체적으로는 string | number | symbol의 서브 타입)이어야 합니다.
  따라서 문자열 타입의 유니온 타입을 `K`로 사용하는 경우가 많습니다.

```ts
type Fruit = "apple" | "orange" | "strawberry";

// FruitNumbers는 {
//     apple: number;
//     orange: number;
//     strawberry: number;
// } 타입
type FruitNumbers = {
  [P in Fruit]: number;
};

const numbers: FruitNumbers = {
  apple: 3,
  orange: 10,
  strawberry: 20,
};
```

- 이 예시에서는 `FruitNumbers`의 정의에 mapped type을 사용했다.
- 'Fruit의 각 구성요소인 P라는 프로퍼티가 number 타입인 객체 타입'을 뜻한다.

[더 복잡한 예시]

```ts
type Fruit = "apple" | "orange" | "strawberry";

// FruitArrays는 {
//     apple: "apple"[];
//     orange: "orange"[];
//     strawberry: "strawberry"[];
// } 타입
type FruitArrays = {
  [P in Fruit]: P[];
};

const numbers: FruitArrays = {
  apple: ["apple", "apple"],
  orange: ["orange", "orange", "orange"],
  strawberry: [],
};
```

- FruitArray는 'apple 프로퍼티가 "apple"[] 타입, orange 프로퍼티가 "orange"[] 타입, strawberry가 "strawberry"[] 타입'이라는 의미가 됩니다.
- 참고로 `{[P in key of T]: U}` 라는 타입(T는 기존의 타입 인수, U는 임의의 타입을 나타냄)은 homomorphic mapped type 라고 부르는 특별한 타입.
- 이 타입은 그 결과가 T의 구조를 보존하는(배열타입에 대한 mapped type의 결과가 그대로 배열 타입이 되는 등) 특별하게 기능함

## 6.7.5 조건부 타입

- 이 타입의 구문은 `X extends Y ? S : T`
- 여기서 X, Y, S, T 모두 어떠한 타입을 뜻함.
- 구문을 언뜻 보면 조건 연산자와 유사해 보이는데, 조건부타입은 타입의 조건 분기를 수행하기위한 타입이기 때문
- 이 타입의 의미 : 'X가 Y의 서브타입이라면 S, 아니라면 T'

```ts
type RestArgs<M> = M extends "string"
  ? [string, string]
  : [number, number, number];

function func<M extends "string" | "number">(mode: M, ...args: RestArgs<M>) {
  console.log(mode, ...args);
}

// 이 호출들은 OK
func("string", "uhyo", "hyo");
func("number", 1, 2, 3);

// 여기는 컴파일 에러
// 에러: Argument of type 'number' is not assignable to parameter of type 'string'.
func("string", 1, 2);
// 에러: Expected 4 arguments, but got 3.
func("number", "uhyo", "hyo");
```

## 6.7.6 내장 타입 능숙하게 사용하기

```ts
// T는 {
//   readonly name: string;
//   readonly age: number;
// }
type T = Readonly<{
  name: string;
  age: number;
}>;
```

```ts
// T는 {
//   name?: string | undefined;
//   age?: number | undefined;
// }
type T = Partial<{
  name: string;
  age: number;
}>;
```

```ts
// T는 {
//   age: number;
// }
type T = Pick<
  {
    name: string;
    age: number;
  },
  "age"
>;
```

```ts
type Union = "uhyo" | "hyo" | 1 | 2 | 3;
// T는 "uhyo" | "hyo"
type T = Extract<Union, string>;
```

```ts
type Union = "uhyo" | "hyo" | 1 | 2 | 3;
// T는 1 | 2 | 3
type T = Exclude<Union, string>;
```
