# 6.7 더욱 고도의 타입

## 6.7.4 mapped types

```ts
type Fruit = "apple" | "orange" | "strawberry";

// FruitNumbers는 {
//     apple: number;
//     orange: number;
//     strawberry: number;
// } 타입
type FruitNumbers = {
  [P in Fruit]: number;
};

const numbers: FruitNumbers = {
  apple: 3,
  orange: 10,
  strawberry: 20,
};
```

```ts
type Fruit = "apple" | "orange" | "strawberry";

// FruitArrays는 {
//     apple: "apple"[];
//     orange: "orange"[];
//     strawberry: "strawberry"[];
// } 타입
type FruitArrays = {
  [P in Fruit]: P[];
};

const numbers: FruitArrays = {
  apple: ["apple", "apple"],
  orange: ["orange", "orange", "orange"],
  strawberry: [],
};
```

## 6.7.5 조건부 타입

```ts
type RestArgs<M> = M extends "string"
  ? [string, string]
  : [number, number, number];

function func<M extends "string" | "number">(mode: M, ...args: RestArgs<M>) {
  console.log(mode, ...args);
}

// 이 호출들은 OK
func("string", "uhyo", "hyo");
func("number", 1, 2, 3);

// 여기는 컴파일 에러
// 에러: Argument of type 'number' is not assignable to parameter of type 'string'.
func("string", 1, 2);
// 에러: Expected 4 arguments, but got 3.
func("number", "uhyo", "hyo");
```

## 6.7.6 내장 타입 능숙하게 사용하기

```ts
// T는 {
//   readonly name: string;
//   readonly age: number;
// }
type T = Readonly<{
  name: string;
  age: number;
}>;
```

```ts
// T는 {
//   name?: string | undefined;
//   age?: number | undefined;
// }
type T = Partial<{
  name: string;
  age: number;
}>;
```

```ts
// T는 {
//   age: number;
// }
type T = Pick<
  {
    name: string;
    age: number;
  },
  "age"
>;
```

```ts
type Union = "uhyo" | "hyo" | 1 | 2 | 3;
// T는 "uhyo" | "hyo"
type T = Extract<Union, string>;
```

```ts
type Union = "uhyo" | "hyo" | 1 | 2 | 3;
// T는 1 | 2 | 3
type T = Exclude<Union, string>;
```
