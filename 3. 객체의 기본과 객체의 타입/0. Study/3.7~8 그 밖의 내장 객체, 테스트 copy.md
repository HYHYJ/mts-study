# 3. 객체의 기본과 객체의 타입

- [3. 객체의 기본과 객체의 타입](#3-객체의-기본과-객체의-타입)
  - [3.7 그 밖의 내장 객체](#37-그-밖의-내장-객체)
    - [3.7.1 Date 객체](#371-date-객체)
    - [3.7.2 정규 표현 객체 (1) 정규 표현의 기본](#372-정규-표현-객체-1-정규-표현의-기본)
    - [3.7.3 정규 표현 객체 (2) 정규 표현을 사용하는 방법](#373-정규-표현-객체-2-정규-표현을-사용하는-방법)
    - [3.7.4 Map 객체·Set 객체](#374-map-객체set-객체)
    - [3.7.5 원시 값인데 프로퍼티가 있다](#375-원시-값인데-프로퍼티가-있다)
  - [3.8 테스트](#38-테스트)
    - [3.8.1 데이터 처리](#381-데이터-처리)
    - [3.8.2 해설](#382-해설)
    - [3.8.3 다른 해답](#383-다른-해답)

## 3.7 그 밖의 내장 객체

👨‍🏫최종적으로는 커스터마이즈된 객체를 직접 만들게 될 텐데, 그러기 위해서는 클래스의 설명(5장)을 먼저 들어야 합니다.
프로그래밍을 배운다는 것은 객체의 사용법을 암기하는것이 아니라, 필요에따라 스스로 조사할 수 있을 만큼의 기초 지식을 익히는 것입니다.

### 3.7.1 📅Date 객체

Date 객체는 날짜와 시간을 나타내는 내장객체 입니다.<br>
하나의 Date객체에는 특정 일시의 정보가 저장 되며, Date 객체가 가진 메서드를 통해 그 정보를 가져오거나 저장된 일시를 바꿀 수 있습니다.<br>
Date 객체를 만드는 가장 단순한 방법은 new Date()라는 식을 이용하는 것입니다.

```
const d = new Date();
console.log(d);
현재의 날짜와 시각이 출력됩니다.
```

그 밖에도

```
getFullYear //연도
getMonth //월
```

등의 방법으로 데이터를 가져올 수 있습니다.<br><br>
그리고 Date 객체는 getFullYear 등의 메서드를 가지며, 이 메서드를 통해 Date 오브젝트에 들어있는 일시 데이터를 변경할 수 있습니다.

```
d.setFullYear(2024);
```

와 같이 메서드를 호출하면 d 가 나타내는 일시가 2024년이 됩니다.(월,일등은 그대로 입니다.)
<br><br>

### 📆ISO 8601 형식

프로그램에서 일시 데이터를 다룰 때에는 ISO 8601 이라는 포맷으,로 다루는 것이 일반적인데, Date 객체는 이형식도 지원합니다.

```
ISO 8601 형식은 아래와 같이 문자열로 일시를 표현합니다.
EX)
2024-01-26T15:00:00+09:00

const d = new Date("2024-01-26T15:00:00+09:00")
console.log(d);
```

맨마지막의 +09:00은 오프셋(협정 세계시간으로부터 9시간 앞선 시간대)을 의미합니다.

반대로 Date 객체의 toISOString 메서드를 호출하면 해당 일시를 ISO 8601 형식의 문자열로 변환할 수 있습니다.

### ☝숫자표현

일시테이터를 다룰깨 쓰이는 또 하나의 표현이 숫자표현이 있습니다.<br>
바로 UNIX 시간이라고 부리는 방식의 일종인데 1970년 1월 1일 0시 0분(협정 세계시)으로 부터 경과한 시간을 밀리초 단위로 나타내는 방식입니다.

```
const date = new Date("2020-02-03T15:00:00+09:00");
const timeNum = date.getTime();
console.log(timeNum); //1580709600000 출력

const date2 = new Date(timeNum);
console.log(date2); //Mon Feb 03 2020 15:00:00 GMT+0900 (한국표준시)라고 출력
```

이러한표현은 숫자 하나라는 간결한 데이터로 일시를 표현할 수 있으므로 많은 경우에 널리 쓰입니다.

### 🙋Date.now()

이 메서드는 현재의 시각을 숫자 표현으로 가져오는 메서드이고 (new Date()).getTime()과 같은 기능을 합니다.

```
console.log(Date.now());
현재 시각을 나타내는 수자가 출력됩니다.
```

### 3.7.2 정규 표현 객체 (1) 정규 표현의 기본

https://regexr.com/ <br>
정규 표현은 문자열에 관한 조건을 나타냅니다. <br>
특수 문자를 포함하지 않는 정규 표현(/abcd/ 등)은 그 문자열 자체가 조건이 됩니다.<br>
즉 /abcd/라는 정규 표현은 'abcd라는 문자열'이라는 조건을 의미합니다.<br>
정규 표현에서는 특수한 문자를 사용해서 다양한 조건을 타나낼 수 있습니다.

```
/ab+c/
+문자는 직전의 문자를 1번이상 반복시킨다는 의미로, ab+c에서는 b가 반복대상 입니다.
이 조건에 맞는 문자열로는 abc, abbc, abbbbbbbc등을 들 수 있습니다.
```

참고로 정규 표현의 조건에 맞는 경우를 매치된다 라고 부릅니다.

```
플래그   의미
  i     대소문자를 구별하지 않고 매치시킨다.
  g     문자열 안에서 한 곳이 아니라 모든 곳에서 매치시킨다.
  m     ^나$를 문자열의 앞뒤뿐만 아니라 행의 앞뒤에도 매치시킨다.
  s     .에 개행 문자를 포함시킨다.
  u     문자열을 UTF-16 코드 유닛이 아니라 유니코드의 코드 포인트로 다룬다.
  y     지정된 시작 위치(lastindex)부터 매치시킨다.
```

### 🎈정규표현 객체의 사용법

정규표현 객체가 가진 메서드 중에서 가장 기본적인 것은 test입니다.<br>
이메서드는 string타입의 인수를 받아서 boolean 타입의 값을 반환하는 메서드로
주어진 문자열 안에 정규표현 조건에 맞는 부분 문자열이 포함돼 있다면 true가 반환됩니다.

```
const r = /ab+c/;

console.log(r.test("abbbbc")); //true
console.log(r.test("Hello, abc world!")); //true
console.log(r.test("ABC")); //true
console.log(r.test("안녕하세요")); //true
```

이 예시를 보면 알 수 있듯이,
주어진 문자열 전체가 정규표현에 완벽히 맞을 필요가 없습니다.<br>
문자열의 어딘가 일부가 정규 표현에 매치되는 것으로 충분합니다.

```
 기호             의미
  *               앞 문자를 0번 이상 반복. ab*c는 abbc뿐민아니라 ac에도 매치된다.
  ?               앞 문자가 있든 없든 상관없음(0번또는 1번 출현).ab?c 는 ac와 abc에 매치된다.
  {숫자}          앞 문자를 숫자번 반복 ab[3]c 는 abbbc와 같다.
  {숫자,}         앞 문자를 숫자번 이상 반복 ab[3, ]c 는 abbbc나 abbbbbbbbc등에 매치된다.
  {숫자1, 숫자2}  앞 문자를 숫자1번 이상 숫자2번 이하 반복 ab[3,5]c 는 abbbc나 abbbbc, abbbbbc에 매치된다.
```

```
 기호   의미
  \s    모든 공백 문자(스페이스, 탭 , 개행등)에 매치된다.
  \S    \s에 매치되지 않는 모든 문자에 매치된다.
  .     개행 이외의 모든 문자에 매치된다.
  \d    숫자에 매치된다.[0-9]와 같다.
  \D    숫자 이외의 문자에 매치된다.[^0-9]와 같다.
  \w    [a-zA-Z0-9_]와 같다.
```

### 🎲위치와 매치되는 구문

대표적인 예시로는 ^와 $입니다. ^는 문자열의 맨앞을 의미하는 기호로 /^abc/라는 정규 표현은 문자열의 맨 앞에 있는 abc에만 매치됩니다.

```
const r =/^abc/;
console.log(r.test("abcdefg")); //true
console.log(r.test("Hello, abcdefg")); //false
```

### 3.7.3 정규 표현 객체 (2) 정규 표현을 사용하는 방법

test 메서드 외에도 몇가지가 더 있습니다.<br>
이용 빈도가 높은 것은 문자열이 지닌 메서드로 구체적으로는 replace와 match가 있습니다.<br>

### 💁replace 메서드

replace메서드는 문자열.replace(정규표현, 대체할 문자열) 형식으로 사용합니다.
<br>
replace 메서드가 호출되면 문자열 안에서 정규표현에 매치되는 부분이 대체할 문자열로 치환된 새로운 문자열이 반환됩니다.

```
//"Hello, foobar world! abbc"
console.log("Hello, abbbbbbbbc world! abbc".replace(/ab+c/,"foobar"));

//"Hello, foobar world! foobar"
console.log("Hello, abbbbbbbbc world! abbc".replace(/ab+c/g,"foobar"));
```

정규표현에 g 플래그가 없으면 가장 처름에 매치된 부분만 치환되는 <br> 반면 g 플래그가 있으면 매치되는 모든 부분 치환 됩니다.

replaceAll이란 메서스도 있는데 이 메서드는 반드시 g 플래그를 붙여야합니다.

### 💁match 메서드

match 메서드는 문자열.match(정규표현) 형식으로 사용합니다<br>
반환값은 정규 표현이 문자열에 매치된다면 문자열의 배열, 매치되지 않는다면 null입니다.<br>
따라서 반환값이 null인지 아닌지를 검사하면 정규표현이 문자열에 매치되는지 여부를 검사할 수 있습니다.

특징: 매치됐을 때의반환값에 있습니다.<br>
반환값인 배열은 매치된 부분 문자열 뿐만아니라 정규표현의 캡처링 그룹에 매치된 문자열의 정보를 포함합니다.

### 👯캡처링 그룹

```
const result = "Hello, abbbbbbbbc world! abc".match(/a(b+)c/);
if (result !== null) {
  console.log(result[0]); //"abbbbbbbbc"

  console.log(result[1]); // "bbbbbbbb"
}
```

result[0]은 정규표현 /a(b+)c/에 매치된 부분 문자열에 해당합니다 따라서"abbbbbbbbc"

result[1]은 캡처링그룹인 (b+)이므로 "bbbbbbbb"

### 3.7.4 Map 객체·Set 객체

Map은 이른바 진정한 연관 배열입니다.<br>
특정한 값(키)에 대응되는 값을 저장하는 기능이 있고 이러한 키⊙값 페어를 원하는 만큼 저장할 수 있는 객체이기 때문입니다.

### ❗❗중요포인트

Map은 평범한 객체보다도 연관 배열로서 뛰어난 존재입니다. 특히 임의의 값을 키로 사용할 수 있다는 점이 중요합니다.<br>
객체의 경우 프로퍼티명은 원칙적으로 문자열이어야 했지만 Map 에서는 그밖의 값도 키로 사용할 수 있습니다.

### 📄Map의 가장 중요한 2개의 메서드

Map에 새로운 키ㅡ값 페어를 추가하는 set메서드와 Map에서지정한 키의 데이터를 가져오는 get메서드 입니다.<br>
Map이 만들어진 직후에는 아무런 데이터도 갖고 있지 않지만 set메서드로 데이터를 추가할 수 있습니다. <br>
이렇게 추가한 데이터는 get메서드로 가져올 수 있습니다.

```
const map: Map<string, number> = new Map();
map.set("foo",1234);

console.log(map.get("foo")); //1234
map에 미리 "foo"를 키로하여 1324라는 값이 저장돼 있었기 때문에 1234라는 number타입을 반환했습니다.


console.log(map.get("bar")); //undefinde
map에 "bar"를 키로 하는 값이 저장돼 있지 않았기 때문에 undefinde 입니다.
```

이처럼 Map 객체는 데이터를 어떠한 키에 연관지어서 저장하는 기능을 가집니다.<br>
이번예시에서는 키다 string 타입이었지만 어떤 타입이더라도 Map의 키로 이용할 수 있습니다.

### 🔨set

set은 Map의 간이버전 같은 객체인데, 타입으로서는 Set<T>와 같이 타입인수를 하나 갖습니다.<br>
Set<T>는 이름 그대로 집합을 나타내는 객체로 최초에는 비어있지만 add메서드로 T타입의 값을 집합에 추가하거나 delete 메서드로 제거 할 수 있습니다.

### 🤖가비지 컬렉션

프로그램 안에서는 객체 리터럴 등에 의해 많은 객체가 만들어지며 프로그램 실행중에는 그실체가 머신의 메모리상에 존재합니다. <br>
대부분 객체는 만들어진 뒤에 조금 사용하고나서는 그 역할이 끝나 다시는 사용되지 않습니다.<br>
따라서 이런 객체를 메모리 상에 계속 두는것은 메모리 낭비 이므로 삭제해야 하지만 자바스크립트에는 객체를 메모리에서 명시적으로 삭제하는 기능이 없습니다.<br>
그러므로 필요 없어진객체를 엔진이 발견하여 자동적으로 메모리에서 삭제합니다.<br>
이공정이 바로 가비지 컬렉션입니다.

### 3.7.5 원시 값인데 프로퍼티가 있다

프로퍼티를 가진다는 것은 객체의 가장 기본적인 특징입니다.<br> 거꾸로 말하면 객체 이외의 값, 다시말해 원시값은 프로퍼티를 가지지 않습니다. <br>
그럼에도 불구하고 타입스크립트에는 원시값이 프로퍼티나 메서드를 가진것처럼 보이기도 합니다.<br>
예를들면 문자열과 숫자 그리고 BigInt가 그렇습니다.

객체값에 대해 프로퍼티 접근을 할 때마다 일시적으로 객체가 만들어 집니다. <br>
문자열의 length프로퍼티나 match메서드 등은 엄밀히 말해 이 일시적인 객체가 가진 프로퍼티 입니다. <br>
그리고 이 일시적인 객체는 프로퍼티 접근이 끝나면 지워집니다.

```
type HasLength = {length: number};
const obj: HasLength ="foobar";
```

이처럼 타입스크립트의 객체 타입은 사실 그 내용물이 정말로 객체라는 보장을 하지 않습니다. <br>
HasLength타입은 실제로 number 타입의 length 프로퍼티를 가진 값의 타입 이며 객체로는 제한되지는 않습니다.<br>
만약 실제로 객체인 값만을 다루고 싶다면 object타입을 사용하면 됩니다.

이렇게하면 {}라는 타입을 처리하는게 문제가 됩니다.<br>
{}값은 어떠한 제약도 받지않는 타입이라는 이야기입니다.<br>
{}타입은 null과 undefined이외의 모든 값을 받아들일 수 있습니다.

{} 타입의 변수에는 이처럼 객체 뿐만아니라 숫자나 문자열 등의 값도 대입할 수 있습니다.<br>
하지만 null과 undefined만은 예외입니다. 그 이유는 자바스크립트에서 null과 undefined가 프로퍼티 접근시에 런타임 에러가 발생하는 유일한 값이고 객체타입의 범주에 속하지 않는다고 간주되기 때문일 것입니다.<br>
null과 undefined도 포함해서 임이의 값을 받을 수 있는 타입이 필요할 경우 unknown타입을 사용하면 됩니다.

## 3.8 테스트

### 3.8.1 데이터 처리

### 3.8.2 해설

### 3.8.3 다른 해답
