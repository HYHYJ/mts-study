# ⟪프로가 되기 위한 타입스크립트 프로그래밍 입문⟫ 샘플 코드

이 압축 파일에 수록된 일련의 텍스트 파일은 ⟪프로가 되기 위한 타입스크립트 프로그래밍 입문⟫이라는 책에 수록된 샘플 코드 파일입니다.

압축 파일의 압축을 풀면 항 번호(예: 1.1.1) 또는 칼럼 번호(예: 칼럼 4)에 해당하는 디렉터리(폴더)가 있고, 각 디렉터리에 샘플 코드의 텍스트 파일(.ts 파일)이 들어 있습니다. .ts 파일의 파일명 번호는 해당 항(또는 열)의 몇 번째 샘플 코드인지를 나타냅니다. 예를 들어, 1.1.3 항에서 두 번째로 나열된 샘플 코드는 '1.1.3_정적 타이핑의 장점 (1) 타입 안전성' 디렉터리에 있는 '2.ts' 파일입니다.

## 주의 사항

각 샘플 코드는 실제 작동하는 완전한 코드가 아닙니다. 해설을 위해 일부 코드를 발췌한 것이거나, 의사 코드인 경우도 있습니다. 양해 부탁드립니다.

## 수록 파일 목록

```
ProTypeScript_SampleCode_KO
├── 1.1.1 자바스크립트에 대한 ‘정적 타이핑’
│   └── 1.ts
├── 1.1.3 정적 타이핑의 장점 (1) 타입 안전성
│   ├── 1.ts
│   └── 2.ts
├── 1.1.4 정적 타이핑의 장점 (2) 문서화와 입력 자동 완성
│   └── 1.ts
├── 1.2.1 타입스크립트 컴파일러의 역할 (1) 타입 검사
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 1.2.2 타입스크립트 컴파일러의 역할 (2) 트랜스파일
│   ├── 1.ts
│   └── 2.ts
├── 1.3.5 첫 타입스크립트 프로그램
│   ├── 1.ts
│   └── 2.ts
├── 2.1.1 문, 식의 기본
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.1.2 문과 식은 ‘결과’의 유무로 구별한다
│   └── 1.ts
├── 2.1.3 표현문
│   └── 1.ts
├── 2.2.1 변수 선언 구문
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.2.2 식별자
│   ├── 1.ts
│   └── 2.ts
├── 2.2.3 변수에 타입 표기하기
│   ├── 1.ts
│   └── 2.ts
├── 2.2.4 let 변수 선언과 변수 재할당
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── 2.3.2 타입스크립트에서의 숫자 타입의 특징
│   ├── 1.ts
│   └── 2.ts
├── 2.3.3 숫자 리터럴
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.3.4 임의 정밀도 정수(BigInt)
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.3.5 문자열 타입과 3종류의 문자열 리터럴
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 2.3.6 문자열 안의 이스케이프 시퀀스
│   ├── 1.ts
│   └── 2.ts
├── 2.3.7 불리언 값과 불리언 리터럴
│   └── 1.ts
├── 2.3.8 null과 undefined
│   ├── 1.ts
│   └── 2.ts
├── 2.3.9 원시 값 변환 (1) 암묵적 변환
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.3.10 원시 값 변환 (2) 명시적 변환
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── 2.4.1 산술 연산자 (1) 이항 연산자
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 2.4.2 산술 연산자 (2) 단항 연산자
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 2.4.3 + 연산자로 문자열 결합하기
│   ├── 1.ts
│   └── 2.ts
├── 2.4.4 비교 연산자와 등가 연산자
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 2.4.5 논리 연산자 (1) 불리언 연산
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.4.6 논리 연산자 (2) 일반형과 단락 평가
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 2.4.7 조건 연산자
│   └── 1.ts
├── 2.4.8 대입 연산자
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.4.9 그 밖의 연산자
│   └── 1.ts
├── 2.5.1 조건 분기 (1) if 문의 기본
│   └── 1.ts
├── 2.5.2 블록
│   └── 1.ts
├── 2.5.3 조건 분기 (2) else 사용
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.5.4 switch 문
│   └── 1.ts
├── 2.5.5 while 문 루프
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 2.5.6 for 문 루프
│   ├── 1.ts
│   └── 2.ts
├── 2.6.2 해설
│   ├── 1.ts
│   └── 2.ts
├── 3.1.1 객체는 ‘연관 배열’이다
│   └── 1.ts
├── 3.1.2 객체 리터럴 (1) 기본 구문
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.1.3 객체 리터럴 (2) 프로퍼티명 지정 방법
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.1.4 프로퍼티 접근 - 값 취득과 대입
│   ├── 1.ts
│   └── 2.ts
├── 3.1.5 객체 리터럴 (3) 전개 구문
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.1.6 객체는 어떤 경우에 ‘같은’가
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 3.2.1 객체 타입 사용법
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.2.2 객체 타입의 타입 검사와 안전성
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.2.3 type 문으로 타입에 별명 붙이기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.2.4 interface 선언으로 객체 타입 선언하기
│   └── 1.ts
├── 3.2.5 임의 프로퍼티명을 허용하는 타입(인덱스 시그니처)
│   └── 1.ts
├── 3.2.6 선택적 프로퍼티 선언
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.2.7 읽기 전용 프로퍼티 선언
│   └── 1.ts
├── 3.2.8 typeof 키워드로 변숫값 얻기
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.3.1 서브타입이란
│   └── 1.ts
├── 3.3.2 프로퍼티의 포함 관계에 의한 서브타입 관계 성립
│   ├── 1.ts
│   └── 2.ts
├── 3.3.3 초과 프로퍼티에 대한 타입 에러
│   ├── 1.ts
│   └── 2.ts
├── 3.4.1 타입 인수를 가지는 타입 선언하기
│   ├── 1.ts
│   └── 2.ts
├── 3.4.2 타입 인수를 가진 타입 사용하기
│   ├── 1.ts
│   └── 2.ts
├── 3.4.3 서브타입 관계에 따른 타입 인수의 제약
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.4.4 선택적 타입 인수
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.5.1 배열 리터럴로 배열 만들기
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.5.2 배열 요소에 접근하기
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.5.3 배열 타입 기법
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.5.4 readonly 배열 타입
│   └── 1.ts
├── 3.5.5 배열의 기능 사용하기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.5.6 for-of 문 루프
│   ├── 1.ts
│   └── 2.ts
├── 3.5.7 튜플 타입
│   ├── 1.ts
│   └── 2.ts
├── 3.6.1 객체의 분해 할당 (1) 기본 패턴
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.6.2 객체의 분해 할당 (2) 중첩 구조 분해
│   ├── 1.ts
│   └── 2.ts
├── 3.6.3 배열의 분해 할당
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── 3.6.4 분해 할당의 기본값
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 3.6.5 rest 패턴으로 객체의 나머지 얻기
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.7.1 Date 객체
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.7.2 정규 표현 객체 (1) 정규 표현의 기본
│   ├── 1.ts
│   └── 2.ts
├── 3.7.3 정규 표현 객체 (2) 정규 표현을 사용하는 방법
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 3.7.4 Map 객체·Set 객체
│   └── 1.ts
├── 3.7.5 원시 값인데 프로퍼티가 있다
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.8.1 데이터 처리
│   └── 1.ts
├── 3.8.2 해설
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 3.8.3 다른 해답
│   └── 1.ts
├── 4.1.1 함수 선언으로 함수 만들기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.1.2 반환값이 없는 함수 만들기
│   ├── 1.ts
│   └── 2.ts
├── 4.1.3 함수 표현식으로 함수 만들기
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.1.4 화살표 함수 표현식으로 함수 만들기
│   └── 1.ts
├── 4.1.5 화살표 함수 표현식의 생략형
│   ├── 1.ts
│   └── 2.ts
├── 4.1.6 메서드 기법으로 함수 만들기
│   └── 1.ts
├── 4.1.7 가변 인수 선언
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.1.8 함수를 호출할 때의 전개 구문
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.1.9 선택적 인수 선언
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.1.10 콜백 함수 사용해 보기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.2.1 함수 타입 표기법
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.2.2 반환값의 타입 표기는 생략할 수 있다
│   ├── 1.ts
│   └── 2.ts
├── 4.2.3 반환값의 타입 표기는 생략해야 하는가
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.2.4 인수의 타입 표기를 생략할 수 있는 경우
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── 4.2.5 호출 시그니처를 이용한 함수 타입 표현
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.3.1 반환값 타입에 따른 서브타입 관계
│   ├── 1.ts
│   └── 2.ts
├── 4.3.2 인수 타입에 따른 서브타입 관계
│   └── 1.ts
├── 4.3.3 인수의 수에 따른 서브타입 관계
│   └── 1.ts
├── 4.4 제네릭
│   └── 1.ts
├── 4.4.1 함수의 타입 인수란
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.4.2 함수의 타입 인수를 선언하는 방법
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 4.4.3 함수의 타입 인수는 생략할 수 있다
│   ├── 1.ts
│   └── 2.ts
├── 4.4.4 타입 인수를 지닌 함수 타입
│   ├── 1.ts
│   └── 2.ts
├── 4.5.1 변수의 스코프란
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.5.2 블록 스코프와 함수 스코프
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 4.6.1 간단한 함수 만들어보기
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.6.2 해설
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 4.6.3 콜백 함수 연습
│   ├── 1.ts
│   └── 2.ts
├── 4.6.4 해설
│   ├── 1.ts
│   └── 2.ts
├── 5.1.1 클래스 선언과 new 구문
│   ├── 1.ts
│   └── 2.ts
├── 5.1.2 프로퍼티 선언
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 5.1.3 메서드 선언
│   ├── 1.ts
│   └── 2.ts
├── 5.1.4 생성자
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 5.1.5 정적 프로퍼티·정적 메서드
│   └── 1.ts
├── 5.1.6 세 종류의 접근 제한자
│   └── 1.ts
├── 5.1.7 생성자 인수에서의 프로퍼티 선언
│   ├── 1.ts
│   └── 2.ts
├── 5.1.8 클래스 표현식으로 클래스 만들기
│   └── 1.ts
├── 5.1.9 또 하나의 비공개 프로퍼티
│   └── 1.ts
├── 5.1.10 클래스의 정적 초기화 블록
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 5.1.11 타입 인수를 지닌 클래스
│   └── 1.ts
├── 5.2.1 클래스 선언은 인스턴스의 타입을 만든다
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 5.2.2 new 시그니처를 이용한 인스턴스화 가시성 표현
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 5.2.3 instanceof 연산자와 타입 좁히기
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 5.3.1 상속 (1) 자식은 부모의 기능을 이어받는다
│   ├── 1.ts
│   └── 2.ts
├── 5.3.2 상속 (2) 부모의 기능 덮어쓰기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 5.3.3 override 수식어의 위력
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 5.3.4 private와 protected의 기능과 사용처
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 5.3.5 implements 키워드에 의한 클래스의 타입 검사
│   ├── 1.ts
│   └── 2.ts
├── 5.4.1 함수 안의 this는 호출 방법에 따라 정해진다
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 5.4.2 화살표 함수에서의 this
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 5.4.3 this를 조작하는 메서드
│   ├── 1.ts
│   └── 2.ts
├── 5.4.4 함수 내부 이외의 this
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 5.5.1 throw 문과 Error 객체
│   ├── 1.ts
│   └── 2.ts
├── 5.5.2 예외를 캐치하는 try-catch 문
│   ├── 1.ts
│   └── 2.ts
├── 5.5.3 예외 처리와 전역 탈출
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 5.5.4 finally로 탈출에 끼어들기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 5.6.1 클래스로 바꿔보기
│   ├── 1.ts
│   └── 2.ts
├── 5.6.2 해설
│   ├── 1.ts
│   └── 2.ts
├── 5.6.3 클래스를 함수로 바꿔보기
│   └── 1.ts
├── 5.6.4 해설
│   └── 1.ts
├── 6.1.1 유니온 타입의 기본
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.1.2 전파되는 유니온 타입
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.1.3 인터섹션 타입이란
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.1.4 유니온 타입과 인터섹션 타입의 밀접한 관계
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.1.5 선택적 프로퍼티의 재등장
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.1.6 옵셔널 체이닝에 따른 프로퍼티 접근
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 6.2.1 4종류의 리터럴 타입
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.2.2 템플릿 리터럴 타입
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.2.3 유니온 타입과 리터럴 타입을 조합해서 사용하는 경우
│   ├── 1.ts
│   └── 2.ts
├── 6.2.4 리터럴 타입 넓히기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   ├── 6.ts
│   ├── 7.ts
│   └── 8.ts
├── 6.2.5 넓혀지는 리터럴 타입·넓혀지지 않는 리터럴 타입
│   └── 1.ts
├── 6.3.1 등가 연산자를 이용한 좁히기
│   ├── 1.ts
│   └── 2.ts
├── 6.3.2 typeof 연산자를 이용한 좁히기
│   ├── 1.ts
│   └── 2.ts
├── 6.3.3 대수적 데이터 타입을 유니온 타입으로 재현하는 테크닉
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.3.4 switch 문으로도 타입을 좁힐 수 있다
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.4.1 lookup 타입이란
│   ├── 1.ts
│   └── 2.ts
├── 6.4.2 keyof 타입이란
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 6.4.3 keyof 타입·lookup 타입과 제네릭
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.4.4 number 타입도 키가 될 수 있다
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.5.1 타입 단언을 이용해서 식의 타입 속이기
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.5.2 as const의 사용법
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.6.1 any 타입이라는 최종 병기
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.6.3 any에 가깝지만 안전한 unknown 타입
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.7.1 object 타입·never 타입
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.7.2 타입 서술어 (사용자 정의 타입 가드)
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── 6.7.3 가변 인자 튜플 타입
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.7.4 mapped types
│   ├── 1.ts
│   └── 2.ts
├── 6.7.5 조건부 타입
│   └── 1.ts
├── 6.7.6 내장 타입 능숙하게 사용하기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 6.8.2 해설
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 6.8.3 서로소 유니온 연습 (2)
│   └── 1.ts
├── 6.8.4 해설
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 6.8.5 서로소 유니온 연습 (3)
│   └── 1.ts
├── 6.8.6 해설
│   └── 1.ts
├── 7.1.1 변수 내보내기와 가져오기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   ├── 6.ts
│   ├── 7.ts
│   └── 8.ts
├── 7.1.2 함수도 내보낼 수 있다
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 7.1.3 default 내보내기와 default 가져오기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   ├── 6.ts
│   ├── 7.ts
│   └── 8.ts
├── 7.1.4 타입 가져오기·내보내기
│   ├── 1.ts
│   ├── 10.ts
│   ├── 11.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   ├── 6.ts
│   ├── 7.ts
│   ├── 8.ts
│   └── 9.ts
├── 7.1.5 그 밖의 관련 구문
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 7.2.1 Node.js의 내장 모듈
│   └── 1.ts
├── 7.2.2 npm이란
│   └── 1.ts
├── 7.3.1 @types 패키지 설치
│   └── 1.ts
├── 7.4.1 파일 읽기
│   └── 1.txt
├── 7.4.2 해설
│   └── 1.ts
├── 7.4.3 path 모듈 사용해 보기
│   └── 1.ts
├── 7.4.4 해설
│   └── 1.ts
├── 8.1.2 싱글 스레드 모델·논블로킹
│   └── 1.ts
├── 8.2.1 콜백 함수란
│   ├── 1.ts
│   └── 2.ts
├── 8.2.2 타이머 예시
│   └── 1.ts
├── 8.2.3 fs 모듈에 의한 파일 처리 예시
│   ├── 1.ts
│   └── 2.ts
├── 8.2.4 동기 처리와 비동기 처리의 순서
│   ├── 1.ts
│   └── 2.ts
├── 8.3.1 프로미스 버전의 fs 사용해 보기
│   └── 1.ts
├── 8.3.2 콜백 함수의 등록과 에러 처리 (1)
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 8.3.3 콜백 함수의 등록과 에러 처리 (2)
│   └── 1.ts
├── 8.3.4 프로미스 객체 직접 만들기
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 8.3.5 프로미스의 정적 메서드 (1)
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 8.3.6 프로미스의 정적 메서드 (2)
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 8.3.7 프로미스의 정적 메서드 (3)
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 8.3.8 프로미스 체인 (1) 체인 만들기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 8.3.9 프로미스 체인 (2) 연쇄적인 비동기 처리
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 8.3.10 프로미스 체인 (3) 에러 처리
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   ├── 6.ts
│   └── 7.ts
├── 8.3.11 dynamic import 구문
│   └── 1.ts
├── 8.4.1 async 함수 만들어보기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 8.4.2 await 식도 사용해 보기
│   ├── 1.ts
│   └── 2.ts
├── 8.4.3 await의 반환값
│   ├── 1.ts
│   └── 2.ts
├── 8.4.4 await과 에러 처리
│   └── 1.ts
├── 8.4.5 async 함수의 다양한 선언 방법
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 8.5.1 fs·promises를 사용해 보기
│   └── 1.ts
├── 8.5.2 해설
│   └── 1.ts
├── 8.5.4 해설
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 9.2.2 strictNullChecks로 null과 undefined를 안전하게 검사하기
│   ├── 1.ts
│   └── 2.ts
├── 9.2.3 타입 누락이나 추론 실패를 방지하는 noImplicitAny 옵션
│   ├── 1.ts
│   └── 2.ts
├── 9.2.4 인덱스 접근을 엄격하게 만드는 noUncheckedIndexedAccess 옵션
│   ├── 1.ts
│   └── 2.ts
├── 칼럼4_타입스크립트에서의 숫자는 IEEE 754 배정밀도 부동소수점수다
│   ├── 1.ts
│   └── 2.ts
├── 칼럼6_논리 대입 연산자의 특수한 기능
│   └── 1.ts
├── 칼럼7_세미콜론을 생략할 수 있다
│   └── 1.ts
├── 칼럼8_객체 프로퍼티와 const
│   └── 1.ts
├── 칼럼9_인덱스 시그니처에 숨어있는 덫
│   ├── 1.ts
│   └── 2.ts
├── 칼럼10_typeof는 언제 사용해야 하는가
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 칼럼13_배열 요소 접근의 비밀스러운 위험성
│   └── 1.ts
├── 칼럼14_return 문과 세미콜론 생략의 함정
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 칼럼15_함수도 객체의 일종이다
│   ├── 1.ts
│   └── 2.ts
├── 칼럼17_메서드 기법과 서브타입 관계
│   └── 1.ts
├── 칼럼18_읽기 전용 프로퍼티의 서브타입에 대하여
│   ├── 1.ts
│   ├── 2.ts
│   └── 3.ts
├── 칼럼19_타입 인수는 어떻게 추론되는가
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   └── 5.ts
├── 칼럼20_var에 의한 변수 선언
│   └── 1.ts
├── 칼럼21_클래스도 변수다
│   └── 1.ts
├── 칼럼22_변수명의 네임스페이스와 타입명의 네임스페이스
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 칼럼23_상속으로 명백해지는 private와 #의 차이
│   └── 1.ts
├── 칼럼24_내장 객체와 클래스 (예시- 배열 상속)
│   ├── 1.ts
│   └── 2.ts
├── 칼럼25_throw는 무엇이든 던질 수 있다
│   ├── 1.ts
│   └── 2.ts
├── 칼럼26_두 종류의 ‘없다’ - 존재하지 않을지도 모르는 프로퍼티를 가져올 수 없는 이유
│   ├── 1.ts
│   └── 2.ts
├── 칼럼28_타입 단언의 낡은 기법
│   └── 1.ts
├── 칼럼29_!를 이용해서 null과 undefined 무시하기
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 칼럼30_any를 is로 바꿔보기
│   ├── 1.ts
│   └── 2.ts
├── 칼럼31_모듈과 캡슐화
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   ├── 4.ts
│   ├── 5.ts
│   └── 6.ts
├── 칼럼32_모듈의 실체는 하나다
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 칼럼34_스크립트와 모듈
│   ├── 1.ts
│   ├── 2.ts
│   ├── 3.ts
│   └── 4.ts
├── 칼럼36_CommonJS 모듈이란
│   ├── 1.ts
│   └── 2.ts
├── 칼럼37_타입 정의 파일을 직접 만들려면
│   └── 1.ts
├── 칼럼38_top-level await
│   ├── 1.ts
│   └── 2.ts
└── README.txt
```

