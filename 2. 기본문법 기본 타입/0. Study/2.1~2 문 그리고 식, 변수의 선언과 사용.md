# 2. 기본 문법, 기본 타입

- [2. 기본 문법, 기본 타입](#2-기본-문법-기본-타입)
  - [2.1 문, 그리고 식](#21-문-그리고-식)
    - [2.1.1 문, 식의 기본](#211-문-식의-기본)
    - [2.1.2 문과 식은 '결과'의 유무로 구별한다.](#212-문과-식은-결과의-유무로-구별한다)
    - [2.1.3 표현문](#213-표현문)
  - [2.2 변수의 선언과 사용](#22-변수의-선언과-사용)
    - [2.2.1 변수 선언 구문](#221-변수-선언-구문)
    - [2.2.2 식별자](#222-식별자)
    - [2.2.3 변수에 타입 표기하기](#223-변수에-타입-표기하기)
    - [2.2.4 let 변수 선언과 변수 재할당](#224-let-변수-선언과-변수-재할당)

## 2.1 문, 그리고 식

### 2.1.1 문, 식의 기본

`문(sentence)`은 타입스크립트 프로그램의 기본 구성 단위.  
문을 나열함으로써 프로그램을 만듦.  
프로그램의 흐름은 문에 의해 기술됨.

```
const greeting = "Hello, "; //이 자체는 문
const target = "world!"; //이 자체는 문
console.log(greeting + target); //이 자체는 문
```

`식(expression)`은 문 안에 자리함.
`"hello"`는 문자열 리터럴이라는 식. (2.3.5에서 나옴)
식은 말 그대로 '문자열'을 나타내는 것 
변수명도 식, 변수명은 식으로 사용 가능하니까
```
const greeting = "Hello, "; // 'Hello,' 식
const target = greeting; // 변수명 + 변수명도 식.
// "Hello, Hello, "라고 출력된다 !!
console.log(greeting + target); // 자체는 문이나 greeting + target는 식
```   
변수명 + 변수명도 식.

```const 변수명 = 식;```

```
const greeting = "Hello, ";  // "Hello, " 식 (리터럴) / 
const target = "world!"; // "world!" 식 (리터럴)
//'Hello, world!'출력
console.log(greeting + target); // greeting + target 식 (연산자 = 식+식 형태 2.4.3에서 나옴) 
```



### 2.1.2 문과 식은 '결과'의 유무로 구별한다.


식은 일반적으로 무언가의 계산을 나타내고 ```그 계산 결과가 식의 결과```가 된다.
문은 아님. 문은 직접적인 결과를 가지지 아니한다.

앞에 나왔던 
```greeting + target``` 식은 변수 greeting 내용물과 target 내용물을 결합하는 계산을 수행 그 결과가 식의 결과로 성립되어서 식

```const greeting = 'Hello,'```는 greeting 변수를 만드는 문이나 직접적으로 계산하는 바 없다. 단, 'Hello,'는 식

=> 실제 계산 수행 = 식 ! 문은 프로그램 구조를 지정해서 그 계산을 조합할 수 있게 해주는 존재

```식은 계산식으로 결과물을 직접적으로 가짐. 문은 그 식의 결과를 조합할 수 있게 하고 담고 흐름을 주관한다.```

식을 문안에서 사용하거나 서로 조합해서 복잡한 식을 만들 듯이
문도 문 안에서 복잡한 문을 만들 수 있다.

```
//if문 안에 console문이 들어간 문문 조합

if (i < 10) {
  console.log("i는 10 미만입니다"); //"i는 10 미만입니다"는 문자 리터럴식이지만 콘솔 전체는 문 ! 문안에 식 ! 문식이
}
```

문은 두종류로 나뉘기도 하는데 
선언문 - const로 변수를 만드는 문으로 정식명칭이 '변수 선언'이다.
그리고 그 외로 나뉨 큰 차이점은 없음

### 2.1.3 표현문

식 다음에 세미콜론 ? 표현문 !

```console.log(greeting + target);``` // 위에서 말했듯 이 자체는 문임 greeting + target 이게 식임 식의 끝에 세미콜론 붙어서 표현문이 된 것

함수 호출은 식에 포함됨. 함수 호출이 식인 이유 ? 함수 호출이 반환 값이라는 결과를 동반하기 때문 !

자바스크립트에서 함수는 값으로 취급된다.
```
const functionExpression = function () {
  console.log('함수 표현식');
}

//결과
console.log(functionExpression);

-> f () {
  console.log('함수 표현식');
}
이렇게 함수를 값마냥 내보냄.
```

표현문의 기능은 주어진 식을 실행하는 것이 전부이다.

표현문은 식을 실행하고 싶으나 결과는 필요없을 때 이용

앞으로 짤때 별 생각없이 함수 호출하고 뒤에 세미콜론 넣으면 문의 일종인 표현문을 사용하고 있다고 생각하면 된다.



## 2.2 변수의 선언과 사용


### 2.2.1 변수 선언 구문

변수선언의 기본형

```const 변수명 = 식;```

식의 결과값이 변수명에 대입되어 들어간다. 

```
const greeting = "Hello, ";
const target = "world!";
const text = greeting + target;
console.log(text);
```


### 2.2.2 식별자

변수명으로 사용 가능한 것 '식별자'

const/if 같은 예약어 사용은 불가하다.
한글 사용 가능
숫자가 앞에 사용될 수 없음
foo1 가능 1foo 불가능

### 2.2.3 변수에 타입 표기하기

타입표기는 변수를 선언할때 변수 타입을 명시해준다.

```cosnt 변수명:타입 = 식;``` // 콜론 : 붙이고 타입명
``` const greeting: string ='Hello'```
``` const greeting: string = 123``` 오류

### 2.2.4 let 변수 선언과 변수 재할당
let 으로 선언된 변수는 재할당 가능하다. (이미 선언된 변수에 다른 값을 넣는 것)
let은 선언 시에 값을 할당하지 않아도 된다.

```
let greeting, target;
greeting = "Hello, ";
target = "world!";
console.log(greeting + target);
```

타입스크립트 컴파일러가 타입 표기가 붙은 변수를 값 할당 전에 사용하려 하면 오류를 보냄.

```
let greeting: string, target: string;
greeting = "Hello, ";
//target에 값 없어서 오류 오류 ~
console.log(greeting + target);
```

